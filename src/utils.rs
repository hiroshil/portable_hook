use std::{ffi::CString, ffi::OsString, ffi::CStr};
use windows::core::{PCSTR, PCWSTR};
use windows::Win32::System::LibraryLoader::{GetModuleHandleW, GetProcAddress};

pub fn get_module_symbol_address(module: &str, symbol: &str) -> Option<usize> {
  let module = module
    .encode_utf16()
    .chain(std::iter::once(0))
    .collect::<Vec<u16>>();
  let symbol = CString::new(symbol).unwrap();
  unsafe {
    let handle = GetModuleHandleW(PCWSTR(module.as_ptr() as _)).unwrap();
    match GetProcAddress(handle, PCSTR(symbol.as_ptr() as _)) {
      Some(func) => Some(func as usize),
      None => None,
    }
  }
}

// convert string data with support for checking trailing 0 and null string
//
// fn modified from https://users.rust-lang.org/t/u8-array-to-string/108735/9 by AI
pub fn u8_array_to_string(input: &[u8]) -> Result<String, std::string::FromUtf8Error> {
    // Attempt to interpret the input as a null-terminated C string
    match CStr::from_bytes_until_nul(input) {
        Ok(cstr) => {
            // Convert the valid portion (up to the first null terminator) to a String
            Ok(String::from_utf8_lossy(cstr.to_bytes()).into_owned())
        }
        Err(_) => {
            // If no null terminator is found, treat the entire input as UTF-8
            String::from_utf8(input.to_vec())
        }
    }
}

// fn generated by AI
pub fn u16_array_to_string(input: &[u16]) -> Result<String, std::string::FromUtf16Error> {
    // Find the position of the first nul terminator.
    let nul_position = input.iter().position(|&r| r == 0).unwrap_or(input.len());

    // If the entire array is just a NUL terminator, return an empty string
    if nul_position == 0 {
        return Ok(String::new());
    }

    // Convert the slice up to the nul terminator into a String
    let result = String::from_utf16(&input[0..nul_position])?;

    Ok(result)
}